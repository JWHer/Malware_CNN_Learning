#include "ByteEntropy.h"
using namespace std;

ByteEntropy::ByteEntropy()
{
	this->path = "";
	verbose = false;
	isBin = false;
}

ByteEntropy::ByteEntropy(string path)
{
	this->path = path;
	verbose = false;
	isBin = false;
}

ByteEntropy::~ByteEntropy()
{
	
}

void ByteEntropy::setpath(string path) {
	this->path = path;
}

float* ByteEntropy::calEntropy()
{
	if (path == "")  return NULL;

	ifstream file_in(path, ios::binary);
	if (file_in.fail()) {
		if (verbose) cout << "invalid path : " << path << endl;
		return NULL;
	}

	// Calculate length
	file_in.seekg(0, ios::end);
	int length = file_in.tellg();
	file_in.seekg(0, ios::beg);

	// Create Buffer
	char* byte = new char[length+1];
	file_in.read(byte, length);
	byte[length] = '\0';

	file_in.close();

	// Parse if not Binary
	if (!isBin) {
		vector<char> tmp;

		char* context=NULL;
		char* ptr = strtok_s(byte, " ", &context);
		while (ptr != NULL) {
			if (strlen(ptr) > 2) {
				char* c = NULL;
				ptr = strtok_s(ptr, "\r\n", &c);
			}

			if (strlen(ptr) == 2) {
				char c = (int)strtol(ptr, NULL, 16);
				tmp.push_back(c);
			}
			ptr=strtok_s(context, " ", &context);
		}
		delete[] byte;
		length = tmp.size();
		byte = new char[length];
		copy(tmp.begin(), tmp.end(), byte);
	}

	// Create Frequency
	float* freq = new float[256];
	fill_n(freq, 256, 0.0f);

	// Calculate Frequency
	for (int i = 0; i < length; i++) {
		freq[byte[i] + 128] += 1;
	}
	delete[] byte;

	// Calculate Entropy
	for (int i = 0; i < 256; i++) {
		if (freq[i] == 0.0f) continue;
		freq[i] /= length;
		freq[i] *= -log2f(freq[i]);
	}

	if(verbose)
		for (int i = 0; i < 256; i++) {
			cout << i << ' : ' << freq[i] << endl;
		}

	return freq;
}

int ByteEntropy::save()
{
	float* freq=calEntropy();
	if (freq == NULL) {
		if(verbose)
			cout << "Save Failed" << endl;
		return -1;
	}
	string nPath = path.substr(0, path.rfind('.')) + ".csv";
	ofstream file_out(nPath);
	for (int i = 0; i < 256; i++) {
		file_out << freq[i] << ",";
	}
	delete[] freq;
	return 0;
}